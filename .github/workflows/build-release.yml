name: Build and Release VxKex

on:
  push:
    tags:
      - 'v*.*.*'  # 当推送 v1.0.0 格式的标签时触发
  workflow_dispatch:  # 允许手动触发
    inputs:
      version:
        description: 'Version number (e.g., 1.1.3.1428)'
        required: true
        default: '1.1.3.1428'

env:
  SOLUTION_NAME: VxKex.sln
  BUILD_CONFIGURATION: Release

jobs:
  build:
    name: Build VxKex Installer
    runs-on: windows-2019  # 使用 Windows Server 2019 (包含 VS2019)

    steps:
    # ========== 步骤 1: 检出代码 ==========
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 获取完整历史用于版本号生成

    # ========== 步骤 2: 设置 MSBuild 环境 ==========
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      with:
        vs-version: '[16.0,17.0)'  # Visual Studio 2019

    # ========== 步骤 3: 恢复 NuGet 包 ==========
    - name: Restore NuGet Packages
      run: nuget restore ${{ env.SOLUTION_NAME }}

    # ========== 步骤 4: 构建 x86 版本 ==========
    - name: Build x86 (Win32)
      run: |
        msbuild ${{ env.SOLUTION_NAME }} `
          /p:Configuration=${{ env.BUILD_CONFIGURATION }} `
          /p:Platform=Win32 `
          /m `
          /v:minimal

    # ========== 步骤 5: 构建 x64 版本 ==========
    - name: Build x64
      run: |
        msbuild ${{ env.SOLUTION_NAME }} `
          /p:Configuration=${{ env.BUILD_CONFIGURATION }} `
          /p:Platform=x64 `
          /m `
          /v:minimal

    # ========== 步骤 6: 收集构建产物 ==========
    - name: Collect Build Artifacts
      shell: pwsh
      run: |
        # 创建打包目录
        New-Item -ItemType Directory -Force -Path ".\PackageRoot"
        New-Item -ItemType Directory -Force -Path ".\PackageRoot\x86"
        New-Item -ItemType Directory -Force -Path ".\PackageRoot\x64"

        # 复制 x86 产物
        Write-Host "Copying x86 binaries..."
        Get-ChildItem -Path ".\Release" -Recurse -Include "*.dll","*.exe" |
          Copy-Item -Destination ".\PackageRoot\x86" -Force

        # 复制 x64 产物
        Write-Host "Copying x64 binaries..."
        Get-ChildItem -Path ".\x64\Release" -Recurse -Include "*.dll","*.exe" |
          Copy-Item -Destination ".\PackageRoot\x64" -Force

        # 复制文档和其他资源
        Copy-Item -Path ".\00-Documentation\*" -Destination ".\PackageRoot" -Recurse -Force
        Copy-Item -Path ".\README.md" -Destination ".\PackageRoot" -Force

        Write-Host "Build artifacts collected successfully"

    # ========== 步骤 7: 安装 Inno Setup ==========
    - name: Install Inno Setup
      shell: pwsh
      run: |
        $InnoSetupUrl = "https://jrsoftware.org/download.php/is.exe"
        $InnoSetupInstaller = "$env:TEMP\innosetup.exe"

        Write-Host "Downloading Inno Setup..."
        Invoke-WebRequest -Uri $InnoSetupUrl -OutFile $InnoSetupInstaller

        Write-Host "Installing Inno Setup..."
        Start-Process -FilePath $InnoSetupInstaller -ArgumentList "/VERYSILENT","/SUPPRESSMSGBOXES","/NORESTART" -Wait

        # 添加到 PATH
        $InnoSetupPath = "C:\Program Files (x86)\Inno Setup 6"
        echo "$InnoSetupPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    # ========== 步骤 8: 创建 Inno Setup 脚本 ==========
    - name: Create Inno Setup Script
      shell: pwsh
      run: |
        # 获取版本号
        $Version = if ($env:GITHUB_REF -match 'refs/tags/v(.*)') {
          $matches[1]
        } elseif ($env:GITHUB_EVENT_INPUTS_VERSION) {
          $env:GITHUB_EVENT_INPUTS_VERSION
        } else {
          "1.1.3.1428"
        }

        Write-Host "Building installer for version: $Version"

        # 创建 ISS 脚本文件
        @"
#define MyAppName "VxKex"
#define MyAppVersion "$Version"
#define MyAppPublisher "VXsoft"
#define MyAppURL "https://github.com/i486/VxKex"
#define MyAppExeName "KexCfg.exe"

[Setup]
AppId={{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}/issues
AppUpdatesURL={#MyAppURL}/releases
DefaultDirName={autopf}\VxKex
DefaultGroupName=VxKex
AllowNoIcons=yes
; LicenseFile=LICENSE
OutputDir=.
OutputBaseFilename=VxKex-{#MyAppVersion}-Setup
; SetupIconFile=KexGui\icon.ico
Compression=lzma2/ultra64
SolidCompression=yes
WizardStyle=modern
ArchitecturesAllowed=x64compatible
ArchitecturesInstallIn64BitMode=x64compatible
PrivilegesRequired=admin
MinVersion=6.1sp1

; 静默安装支持
SilentMode=silent
DisableWelcomePage=no

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"
Name: "chinesesimplified"; MessagesFile: "compiler:Languages\ChineseSimplified.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
; x64 文件
Source: "PackageRoot\x64\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs; Check: Is64BitInstallMode
; x86 文件
Source: "PackageRoot\x86\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs; Check: not Is64BitInstallMode
; 文档
Source: "PackageRoot\*.md"; DestDir: "{app}"; Flags: ignoreversion
Source: "PackageRoot\*.txt"; DestDir: "{app}\Documentation"; Flags: ignoreversion recursesubdirs

[Icons]
Name: "{group}\VxKex Configuration"; Filename: "{app}\{#MyAppExeName}"
Name: "{group}\VxKex Documentation"; Filename: "{app}\Documentation"
Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"
Name: "{autodesktop}\VxKex"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

[Code]
const
  IFEO_BASE_KEY = 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options';
  FLG_APPLICATION_VERIFIER = `$00000100;
  VERIFIER_FLAGS = `$80000000;

function GenerateRandomSubkeyName: String;
var
  Rand1, Rand2: Integer;
begin
  Rand1 := Random(`$FFFFFFFF);
  Rand2 := Random(`$FFFFFFFF);
  Result := Format('VxKex_%08X%08X', [Rand1, Rand2]);
end;

function ExtractFileNameOnly(const FullPath: String): String;
var
  P: Integer;
begin
  P := Length(FullPath);
  while (P > 0) and not (FullPath[P] in ['\', '/']) do
    Dec(P);
  Result := Copy(FullPath, P + 1, MaxInt);
end;

function FindClashVergeInstallPath: String;
var
  InstallPath: String;
  DefaultPath: String;
begin
  Result := '';

  if RegQueryStringValue(HKLM64, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Clash Verge', 'InstallLocation', InstallPath) then
  begin
    if DirExists(InstallPath) then
    begin
      Result := InstallPath;
      Exit;
    end;
  end;

  if RegQueryStringValue(HKLM32, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Clash Verge', 'InstallLocation', InstallPath) then
  begin
    if DirExists(InstallPath) then
    begin
      Result := InstallPath;
      Exit;
    end;
  end;

  if RegQueryStringValue(HKCU, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Clash Verge', 'InstallLocation', InstallPath) then
  begin
    if DirExists(InstallPath) then
    begin
      Result := InstallPath;
      Exit;
    end;
  end;

  DefaultPath := ExpandConstant('{localappdata}\Programs\Clash Verge');
  if DirExists(DefaultPath) then
  begin
    Result := DefaultPath;
    Exit;
  end;

  DefaultPath := ExpandConstant('{pf}\Clash Verge');
  if DirExists(DefaultPath) then
  begin
    Result := DefaultPath;
    Exit;
  end;

  DefaultPath := ExpandConstant('{pf32}\Clash Verge');
  if DirExists(DefaultPath) then
  begin
    Result := DefaultPath;
    Exit;
  end;
end;

function ConfigureVxKexForExe(const ExeFullPath: String; DisableForChild: Boolean): Boolean;
var
  ExeBaseName: String;
  SubkeyName: String;
  IfeoExeKeyPath: String;
  IfeoSubkeyPath: String;
begin
  Result := False;

  if not FileExists(ExeFullPath) then
  begin
    Log('File not found: ' + ExeFullPath);
    Exit;
  end;

  ExeBaseName := ExtractFileNameOnly(ExeFullPath);
  if ExeBaseName = '' then Exit;

  SubkeyName := GenerateRandomSubkeyName;
  IfeoExeKeyPath := IFEO_BASE_KEY + '\' + ExeBaseName;
  IfeoSubkeyPath := IfeoExeKeyPath + '\' + SubkeyName;

  Log('Configuring VxKex for: ' + ExeBaseName);

  try
    if not RegWriteDWordValue(HKLM64, IfeoExeKeyPath, 'UseFilter', 1) then Exit;
    if not RegWriteStringValue(HKLM64, IfeoSubkeyPath, 'FilterFullPath', ExeFullPath) then Exit;
    if not RegWriteStringValue(HKLM64, IfeoSubkeyPath, 'VerifierDlls', 'kexdll.dll') then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'GlobalFlag', FLG_APPLICATION_VERIFIER) then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'VerifierFlags', VERIFIER_FLAGS) then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'KEX_DisableForChild', Ord(DisableForChild)) then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'KEX_DisableAppSpecific', 0) then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'KEX_WinVerSpoof', 0) then Exit;
    if not RegWriteDWordValue(HKLM64, IfeoSubkeyPath, 'KEX_StrongVersionSpoof', 0) then Exit;

    Log('Successfully configured: ' + ExeBaseName);
    Result := True;
  except
    Log('Error configuring: ' + ExeBaseName);
    Result := False;
  end;
end;

procedure AutoConfigureClashVerge;
var
  ClashVergePath: String;
  ExeList: array[0..3] of String;
  ExeFullPath: String;
  I: Integer;
  SuccessCount: Integer;
begin
  Log('Auto-configuring Clash Verge for VxKex...');

  Randomize;
  ClashVergePath := FindClashVergeInstallPath;

  if ClashVergePath = '' then
  begin
    Log('Clash Verge not found, skipping auto-configuration');
    Exit;
  end;

  Log('Found Clash Verge at: ' + ClashVergePath);

  if Copy(ClashVergePath, Length(ClashVergePath), 1) <> '\' then
    ClashVergePath := ClashVergePath + '\';

  ExeList[0] := 'Clash Verge.exe';
  ExeList[1] := 'resources\clash-verge-service.exe';
  ExeList[2] := 'resources\install-service.exe';
  ExeList[3] := 'resources\uninstall-service.exe';

  SuccessCount := 0;
  for I := 0 to 3 do
  begin
    ExeFullPath := ClashVergePath + ExeList[I];
    if ConfigureVxKexForExe(ExeFullPath, True) then
      SuccessCount := SuccessCount + 1;
  end;

  Log('Clash Verge auto-configuration completed: ' + IntToStr(SuccessCount) + '/4');
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssPostInstall then
  begin
    Sleep(1000);
    AutoConfigureClashVerge;
  end;
end;
"@ | Out-File -FilePath "VxKex-Installer.iss" -Encoding UTF8
        Write-Host "Inno Setup script created successfully"

    # ========== 步骤 9: 编译安装程序 ==========
    - name: Compile Installer
      shell: pwsh
      run: |
        $IsccPath = "C:\Program Files (x86)\Inno Setup 6\ISCC.exe"

        if (-not (Test-Path $IsccPath)) {
          Write-Error "Inno Setup compiler not found at: $IsccPath"
          exit 1
        }

        Write-Host "Compiling installer..."
        & $IsccPath "VxKex-Installer.iss"

        if ($LASTEXITCODE -ne 0) {
          Write-Error "Installer compilation failed"
          exit 1
        }

        Write-Host "Installer compiled successfully"

        # 列出生成的安装程序
        Get-ChildItem -Filter "VxKex-*-Setup.exe" | ForEach-Object {
          Write-Host "Generated installer: $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
        }

    # ========== 步骤 10: 创建便携版压缩包 ==========
    - name: Create Portable Package
      shell: pwsh
      run: |
        $Version = if ($env:GITHUB_REF -match 'refs/tags/v(.*)') {
          $matches[1]
        } elseif ($env:GITHUB_EVENT_INPUTS_VERSION) {
          $env:GITHUB_EVENT_INPUTS_VERSION
        } else {
          "1.1.3.1428"
        }

        # 创建 x86 便携版
        Write-Host "Creating x86 portable package..."
        Compress-Archive -Path ".\PackageRoot\x86\*" -DestinationPath "VxKex-$Version-Portable-x86.zip" -Force

        # 创建 x64 便携版
        Write-Host "Creating x64 portable package..."
        Compress-Archive -Path ".\PackageRoot\x64\*" -DestinationPath "VxKex-$Version-Portable-x64.zip" -Force

        Write-Host "Portable packages created successfully"

    # ========== 步骤 11: 生成校验和 ==========
    - name: Generate Checksums
      shell: pwsh
      run: |
        Write-Host "Generating SHA256 checksums..."

        Get-ChildItem -Filter "VxKex-*.exe","VxKex-*.zip" | ForEach-Object {
          $Hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash
          $HashFile = "$($_.Name).sha256"
          "$Hash  $($_.Name)" | Out-File -FilePath $HashFile -Encoding ASCII
          Write-Host "  $($_.Name): $Hash"
        }

    # ========== 步骤 12: 上传构建产物 ==========
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: VxKex-Installers
        path: |
          VxKex-*-Setup.exe
          VxKex-*-Portable-*.zip
          *.sha256
        retention-days: 30

    # ========== 步骤 13: 创建 GitHub Release ==========
    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        draft: false
        prerelease: false
        generate_release_notes: true
        files: |
          VxKex-*-Setup.exe
          VxKex-*-Portable-*.zip
          *.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # ========== 步骤 14: 输出构建总结 ==========
    - name: Build Summary
      shell: pwsh
      run: |
        Write-Host ""
        Write-Host "=========================================="
        Write-Host "Build Summary"
        Write-Host "=========================================="
        Write-Host "Configuration: ${{ env.BUILD_CONFIGURATION }}"
        Write-Host "Platforms: Win32 + x64"
        Write-Host ""
        Write-Host "Generated Files:"
        Get-ChildItem -Filter "VxKex-*" | ForEach-Object {
          Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
        }
        Write-Host "=========================================="
